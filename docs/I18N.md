# CafeHub Internationalization (i18n)

This is a quick, beginner‑friendly guide for your future self on how text and languages work in CafeHub.

CafeHub uses **i18next + react‑i18next** with **language detection** and **static JSON files** for translations.

---

## 1. How to add a new language (step by step)

Let’s say you want to add **Spanish (`es`)** or any other language.

1. **Pick a language code**
   - Use standard two‑letter codes like `es`, `de`, `fr`, etc.

2. **Create the folder and file**
   - Go to `public/locales/`
   - Copy an existing folder (for example `en`) and rename it:
     - `public/locales/en/common.json` → `public/locales/es/common.json`

3. **Translate the strings**
   - Open your new `common.json` and replace the English values with your translations.
   - **Important**: keep the **keys and structure** the same, only change the values.
   - Example:
     ```json
     {
       "nav": {
         "brandTitle": "CafeHub",
         "brandTagline": "Encuentra tu próximo lugar favorito"
       }
     }
     ```

4. **(Optional) Allow the language in the app**
   - `src/i18n/index.ts` already lists: `supportedLngs: ['tr', 'en', 'es', 'de']`.
   - If you add another language, include its code in that array.

5. **(Optional) Expose it in the UI switcher**
   - Open `src/components/layout/LanguageSwitcher.tsx`.
   - Add your language to the `LANGUAGES` array, for example:
     ```ts
     const LANGUAGES = [
       { code: 'tr', label: 'TR' },
       { code: 'en', label: 'EN' },
       { code: 'es', label: 'ES' } // new language
     ] as const;
     ```
   - This makes it selectable in the navbar.

That’s it: as long as the JSON file exists and the language is in `supportedLngs`, i18next can use it.

---

## 2. Where translation files are stored

- All translation files live under:
  - `public/locales/<lang>/common.json`
- Currently used:
  - `public/locales/tr/common.json` – **Turkish (default)**
  - `public/locales/en/common.json` – English
  - `public/locales/es/common.json` – Spanish placeholder (currently English text)
  - `public/locales/de/common.json` – German placeholder (currently English text)

**Key points:**

- The **file name** `common.json` is the translation namespace used by the app.
- The **key paths** (like `nav.brandTagline`) must match between languages.

---

## 3. How to add new translatable text

Whenever you add new user‑visible text, follow these steps:

1. **Add a key to the JSON files**
   - Pick a logical place and key name.
   - Example: adding a new empty‑state message for favorites.
   - In `public/locales/en/common.json`:
     ```json
     {
       "favorites": {
         "empty": "You don’t have any favorite cafes yet."
       }
     }
     ```
   - In `public/locales/tr/common.json`:
     ```json
     {
       "favorites": {
         "empty": "Henüz favori kafen yok."
       }
     }
     ```

2. **Use `useTranslation()` in the component**
   - Import and call the hook:
     ```ts
     import { useTranslation } from 'react-i18next';

     const { t } = useTranslation();
     ```

3. **Replace the hardcoded string with `t('key.path')`**
   - Instead of:
     ```tsx
     <p>You don’t have any favorite cafes yet.</p>
     ```
   - Use:
     ```tsx
     <p>{t('favorites.empty')}</p>
     ```

4. **For dynamic values, pass options**
   - Example used in `CafeCard`:
     ```tsx
     t('cafes.distance', { minutes: cafe.distanceMinutesWalk })
     // "4 min walk" / "4 dk yürüyüş"
     ```

Summary: **add key/value in JSON → use `t('your.key')` in React → no hardcoded text**.

---

## 4. How the language switcher works

File: `src/components/layout/LanguageSwitcher.tsx`

- It uses `react-i18next`’s `i18n` instance:
  ```ts
  const { i18n } = useTranslation();
  const currentCode = (i18n.language || 'tr').split('-')[0];
  ```
- It renders buttons for each language in the `LANGUAGES` array (currently `TR` and `EN`).
- On click:
  ```ts
  i18n.changeLanguage(code);
  window.localStorage.setItem('cafehub-language', code);
  ```
  - `changeLanguage` updates the current language in memory.
  - The choice is saved to `localStorage` under `cafehub-language`.

**Language detection on startup** (in `src/i18n/index.ts`):

- The app initializes i18next with:
  - `order: ['localStorage', 'navigator']`
  - `fallbackLng: 'tr'`
- This means:
  1. If you previously chose a language in the switcher, the app reuses it.
  2. Otherwise it looks at the browser language (e.g. `en-US` → `en`).
  3. If not supported, it falls back to **Turkish**.

So the switcher is just a thin UI over `i18n.changeLanguage` + `localStorage`.

---

## 5. How localized cafe data works

File: `src/data/mockCafes.ts`  
Used in: `src/pages/HomePage.tsx`

### Data sets

- There are two mock data arrays:
  - `mockCafesTr` – Turkish names, descriptions, and addresses.
  - `mockCafesEn` – English names, descriptions, and addresses.

- A helper picks the right one:
  ```ts
  export const getMockCafesForLanguage = (language: string): Cafe[] => {
    const base = (language || 'tr').split('-')[0];

    if (base === 'en') {
      return mockCafesEn;
    }

    // For Turkish and all other languages, default to Turkish data
    return mockCafesTr;
  };
  ```

### How the page uses it

- In `HomePage.tsx`:
  ```ts
  const { t, i18n } = useTranslation();

  const cafes = useMemo(
    () => getMockCafesForLanguage(i18n.language),
    [i18n.language]
  );
  ```

- When you change the language:
  - `i18n.language` changes.
  - `getMockCafesForLanguage` is called again.
  - The list re-renders with Turkish or English cafe names/descriptions.

### If you want to support more localized data

- Add another array (e.g. `mockCafesDe`) and extend `getMockCafesForLanguage`:
  ```ts
  if (base === 'de') {
    return mockCafesDe;
  }
  ```
- For languages you don’t localize yet, it’s fine to **fall back to Turkish or English**.

---

If you forget anything later, you can always:

- Check `src/i18n/index.ts` to see how i18next is wired.
- Look at `public/locales/tr/common.json` + `public/locales/en/common.json` for examples.
- Search for `useTranslation(` in the codebase to copy existing patterns.

